import{g as X,f as v,R as U,e as x,h as S,S as I,N as Y,G as T,ae as Z,x as oo,ac as no,ad as io,af as B,ag as so,ah as G,ai as eo,p as q,I as J,aj as y,ak as c,_ as K,al as C,k as $,b as O,v as V}from"./DED8QcuK.js";import"./DlAUqK2U.js";import"./kfcw7JiG.js";import"./BvgrIc9p.js";import"./DaiN6MYX.js";import"./CuyTH5qY.js";const L=.5,to=2,p=0,m=1,H=60,N=0,ao=.01,ro=Math.PI*to;function uo(n){const o=n.initialPosition,{dx:i,dy:s}=S(o,n.position),e=Math.abs(i),a=Math.abs(s),{maxDistance:r}=n.retina,t=r.horizontal,u=r.vertical;if(!t&&!u)return;const f=(t&&e>=t)??!1,d=(u&&a>=u)??!1;if((f||d)&&!n.misplaced)n.misplaced=!!t&&e>t||!!u&&a>u,t&&(n.velocity.x=n.velocity.y*L-n.velocity.x),u&&(n.velocity.y=n.velocity.x*L-n.velocity.y);else if((!t||e<t)&&(!u||a<u)&&n.misplaced)n.misplaced=!1;else if(n.misplaced){const l=n.position,h=n.velocity;t&&(l.x<o.x&&h.x<p||l.x>o.x&&h.x>p)&&(h.x*=-x()),u&&(l.y<o.y&&h.y<p||l.y>o.y&&h.y>p)&&(h.y*=-x())}}function co(n,o,i,s,e,a,r){ho(n,r);const t=n.gravity,u=t?.enable&&t.inverse?-m:m;e&&i&&(n.velocity.x+=e*r.factor/(H*i)),t?.enable&&i&&(n.velocity.y+=u*(t.acceleration*r.factor)/(H*i));const f=n.moveDecay;n.velocity.multTo(f);const d=n.velocity.mult(i);t?.enable&&s>p&&(!t.inverse&&d.y>=p&&d.y>=s||t.inverse&&d.y<=p&&d.y<=-s)&&(d.y=u*s,i&&(n.velocity.y=d.y/i));const l=n.options.zIndex,h=(m-n.zIndexFactor)**l.velocityRate;d.multTo(h),d.multTo(a);const{position:g}=n;g.addTo(d),o.vibrate&&(g.x+=Math.sin(g.x*Math.cos(g.y))*a,g.y+=Math.cos(g.y*Math.sin(g.x))*a)}function fo(n,o,i){const s=n.container;if(!n.spin)return;const e=n.spin.direction===U.clockwise,a={x:e?Math.cos:Math.sin,y:e?Math.sin:Math.cos};n.position.x=n.spin.center.x+n.spin.radius*a.x(n.spin.angle)*i,n.position.y=n.spin.center.y+n.spin.radius*a.y(n.spin.angle)*i,n.spin.radius+=n.spin.acceleration*i;const r=Math.max(s.canvas.size.width,s.canvas.size.height),t=r*L;n.spin.radius>t?(n.spin.radius=t,n.spin.acceleration*=-m):n.spin.radius<N&&(n.spin.radius=N,n.spin.acceleration*=-m),n.spin.angle+=o*ao*(m-n.spin.radius/r)}function ho(n,o){const i=n.options,s=i.move.path;if(!s.enable)return;if(n.lastPathTime<=n.pathDelay){n.lastPathTime+=o.value;return}const a=n.pathGenerator?.generate(n,o);a&&n.velocity.addTo(a),s.clamp&&(n.velocity.x=I(n.velocity.x,-m,m),n.velocity.y=I(n.velocity.y,-m,m)),n.lastPathTime-=n.pathDelay}function yo(n){return n.slow.inRange?n.slow.factor:m}function lo(n){const o=n.container,i=n.options,s=i.move.spin;if(!s.enable)return;const e=s.position??{x:50,y:50},a=.01,r={x:e.x*a*o.canvas.size.width,y:e.y*a*o.canvas.size.height},t=n.getPosition(),u=X(t,r),f=v(s.acceleration);n.retina.spinAcceleration=f*o.retina.pixelRatio,n.spin={center:r,direction:n.velocity.x>=p?U.clockwise:U.counterClockwise,angle:x()*ro,radius:u,acceleration:n.retina.spinAcceleration}}const vo=2,mo=1,go=1;class xo{init(o){const i=o.options,s=i.move.gravity;o.gravity={enable:s.enable,acceleration:v(s.acceleration),inverse:s.inverse},lo(o)}isEnabled(o){return!o.destroyed&&o.options.move.enable}move(o,i){const s=o.options,e=s.move;if(!e.enable)return;const a=o.container,r=a.retina.pixelRatio;o.retina.moveSpeed??=v(e.speed)*r,o.retina.moveDrift??=v(o.options.move.drift)*r;const t=yo(o),u=a.retina.reduceFactor,f=o.retina.moveSpeed,d=o.retina.moveDrift,l=Y(s.size.value)*r,h=e.size?o.getRadius()/l:mo,g=i.factor||go,E=f*h*t*g/vo,Q=o.retina.maxSpeed??a.retina.maxSpeed;e.spin.enable?fo(o,E,u):co(o,e,E,Q,d,u,i),uo(o)}}async function po(n,o=!0){n.checkVersion("3.9.1"),await n.addMover("base",()=>Promise.resolve(new xo),o)}const bo=2,wo=Math.PI*bo,zo=0,W={x:0,y:0};function Mo(n){const{context:o,particle:i,radius:s}=n;i.circleRange||(i.circleRange={min:zo,max:wo});const e=i.circleRange;o.arc(W.x,W.y,s,e.min,e.max,!1)}const Co=12,Po=360,j=0;class So{constructor(){this.validTypes=["circle"]}draw(o){Mo(o)}getSidesCount(){return Co}particleInit(o,i){const s=i.shapeData,e=s?.angle??{max:Po,min:j};i.circleRange=Z(e)?{min:T(e.min),max:T(e.max)}:{min:j,max:T(e)}}}async function Oo(n,o=!0){n.checkVersion("3.9.1"),await n.addShape(new So,o)}class Vo{constructor(o,i){this._container=o,this._engine=i}init(o){const i=oo(this._engine,o.options.color,o.id,o.options.reduceDuplicates);i&&(o.color=no(i,o.options.color.animation,this._container.retina.reduceFactor))}isEnabled(o){const{h:i,s,l:e}=o.options.color.animation,{color:a}=o;return!o.destroyed&&!o.spawning&&(a?.h.value!==void 0&&i.enable||a?.s.value!==void 0&&s.enable||a?.l.value!==void 0&&e.enable)}update(o,i){io(o.color,i)}}async function Ro(n,o=!0){n.checkVersion("3.9.1"),await n.addParticleUpdater("color",i=>Promise.resolve(new Vo(i,n)),o)}var w;(function(n){n[n.r=1]="r",n[n.g=2]="g",n[n.b=3]="b",n[n.a=4]="a"})(w||(w={}));const ko=/^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i,Do=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i,R=16,Ao=1,_o=255;class Fo{constructor(){this.key="hex",this.stringPrefix="#"}handleColor(o){return this._parseString(o.value)}handleRangeColor(o){return this._parseString(o.value)}parseString(o){return this._parseString(o)}_parseString(o){if(typeof o!="string"||!o?.startsWith(this.stringPrefix))return;const i=o.replace(ko,(e,a,r,t,u)=>a+a+r+r+t+t+(u!==void 0?u+u:"")),s=Do.exec(i);return s?{a:s[w.a]!==void 0?parseInt(s[w.a],R)/_o:Ao,b:parseInt(s[w.b],R),g:parseInt(s[w.g],R),r:parseInt(s[w.r],R)}:void 0}}async function To(n,o=!0){n.checkVersion("3.9.1"),await n.addColorManager(new Fo,o)}var z;(function(n){n[n.h=1]="h",n[n.s=2]="s",n[n.l=3]="l",n[n.a=5]="a"})(z||(z={}));class Uo{constructor(){this.key="hsl",this.stringPrefix="hsl"}handleColor(o){const i=o.value,s=i.hsl??o.value;if(s.h!==void 0&&s.s!==void 0&&s.l!==void 0)return B(s)}handleRangeColor(o){const i=o.value,s=i.hsl??o.value;if(s.h!==void 0&&s.l!==void 0)return B({h:v(s.h),l:v(s.l),s:v(s.s)})}parseString(o){if(!o.startsWith("hsl"))return;const i=/hsla?\(\s*(\d+)\s*[\s,]\s*(\d+)%\s*[\s,]\s*(\d+)%\s*([\s,]\s*(0|1|0?\.\d+|(\d{1,3})%)\s*)?\)/i,s=i.exec(o),e=4,a=1,r=10;return s?so({a:s.length>e?G(s[z.a]):a,h:parseInt(s[z.h],r),l:parseInt(s[z.l],r),s:parseInt(s[z.s],r)}):void 0}}async function Lo(n,o=!0){n.checkVersion("3.9.1"),await n.addColorManager(new Uo,o)}class $o{constructor(o){this.container=o}init(o){const i=o.options.opacity,s=1;o.opacity=eo(i,s);const e=i.animation;e.enable&&(o.opacity.velocity=v(e.speed)/q*this.container.retina.reduceFactor,e.sync||(o.opacity.velocity*=x()))}isEnabled(o){return!o.destroyed&&!o.spawning&&!!o.opacity&&o.opacity.enable&&((o.opacity.maxLoops??0)<=0||(o.opacity.maxLoops??0)>0&&(o.opacity.loops??0)<(o.opacity.maxLoops??0))}reset(o){o.opacity&&(o.opacity.time=0,o.opacity.loops=0)}update(o,i){!this.isEnabled(o)||!o.opacity||J(o,o.opacity,!0,o.options.opacity.animation.destroy,i)}}async function Eo(n,o=!0){n.checkVersion("3.9.1"),await n.addParticleUpdater("opacity",i=>Promise.resolve(new $o(i)),o)}const F=0,P=0;function Io(n){if(n.outMode!==y.bounce&&n.outMode!==y.split||n.direction!==c.left&&n.direction!==c.right)return;n.bounds.right<P&&n.direction===c.left?n.particle.position.x=n.size+n.offset.x:n.bounds.left>n.canvasSize.width&&n.direction===c.right&&(n.particle.position.x=n.canvasSize.width-n.size-n.offset.x);const o=n.particle.velocity.x;let i=!1;if(n.direction===c.right&&n.bounds.right>=n.canvasSize.width&&o>F||n.direction===c.left&&n.bounds.left<=P&&o<F){const e=v(n.particle.options.bounce.horizontal.value);n.particle.velocity.x*=-e,i=!0}if(!i)return;const s=n.offset.x+n.size;n.bounds.right>=n.canvasSize.width&&n.direction===c.right?n.particle.position.x=n.canvasSize.width-s:n.bounds.left<=P&&n.direction===c.left&&(n.particle.position.x=s),n.outMode===y.split&&n.particle.destroy()}function Bo(n){if(n.outMode!==y.bounce&&n.outMode!==y.split||n.direction!==c.bottom&&n.direction!==c.top)return;n.bounds.bottom<P&&n.direction===c.top?n.particle.position.y=n.size+n.offset.y:n.bounds.top>n.canvasSize.height&&n.direction===c.bottom&&(n.particle.position.y=n.canvasSize.height-n.size-n.offset.y);const o=n.particle.velocity.y;let i=!1;if(n.direction===c.bottom&&n.bounds.bottom>=n.canvasSize.height&&o>F||n.direction===c.top&&n.bounds.top<=P&&o<F){const e=v(n.particle.options.bounce.vertical.value);n.particle.velocity.y*=-e,i=!0}if(!i)return;const s=n.offset.y+n.size;n.bounds.bottom>=n.canvasSize.height&&n.direction===c.bottom?n.particle.position.y=n.canvasSize.height-s:n.bounds.top<=P&&n.direction===c.top&&(n.particle.position.y=s),n.outMode===y.split&&n.particle.destroy()}class Ho{constructor(o){this.container=o,this.modes=[y.bounce,y.split]}update(o,i,s,e){if(!this.modes.includes(e))return;const a=this.container;let r=!1;for(const h of a.plugins.values())if(h.particleBounce!==void 0&&(r=h.particleBounce(o,s,i)),r)break;if(r)return;const t=o.getPosition(),u=o.offset,f=o.getRadius(),d=K(t,f),l=a.canvas.size;Io({particle:o,outMode:e,direction:i,bounds:d,canvasSize:l,offset:u,size:f}),Bo({particle:o,outMode:e,direction:i,bounds:d,canvasSize:l,offset:u,size:f})}}const k=0;class No{constructor(o){this.container=o,this.modes=[y.destroy]}update(o,i,s,e){if(!this.modes.includes(e))return;const a=this.container;switch(o.outType){case C.normal:case C.outside:if($(o.position,a.canvas.size,O.origin,o.getRadius(),i))return;break;case C.inside:{const{dx:r,dy:t}=S(o.position,o.moveCenter),{x:u,y:f}=o.velocity;if(u<k&&r>o.moveCenter.radius||f<k&&t>o.moveCenter.radius||u>=k&&r<-o.moveCenter.radius||f>=k&&t<-o.moveCenter.radius)return;break}}a.particles.remove(o,o.group,!0)}}const D=0;class Wo{constructor(o){this.container=o,this.modes=[y.none]}update(o,i,s,e){if(!this.modes.includes(e)||((o.options.move.distance.horizontal&&(i===c.left||i===c.right))??(o.options.move.distance.vertical&&(i===c.top||i===c.bottom))))return;const a=o.options.move.gravity,r=this.container,t=r.canvas.size,u=o.getRadius();if(a.enable){const f=o.position;(!a.inverse&&f.y>t.height+u&&i===c.bottom||a.inverse&&f.y<-u&&i===c.top)&&r.particles.remove(o)}else{if(o.velocity.y>D&&o.position.y<=t.height+u||o.velocity.y<D&&o.position.y>=-u||o.velocity.x>D&&o.position.x<=t.width+u||o.velocity.x<D&&o.position.x>=-u)return;$(o.position,r.canvas.size,O.origin,u,i)||r.particles.remove(o)}}}const A=0,_=0;class jo{constructor(o){this.container=o,this.modes=[y.out]}update(o,i,s,e){if(!this.modes.includes(e))return;const a=this.container;switch(o.outType){case C.inside:{const{x:r,y:t}=o.velocity,u=O.origin;u.length=o.moveCenter.radius,u.angle=o.velocity.angle+Math.PI,u.addTo(O.create(o.moveCenter));const{dx:f,dy:d}=S(o.position,u);if(r<=A&&f>=_||t<=A&&d>=_||r>=A&&f<=_||t>=A&&d<=_)return;o.position.x=Math.floor(V({min:0,max:a.canvas.size.width})),o.position.y=Math.floor(V({min:0,max:a.canvas.size.height}));const{dx:l,dy:h}=S(o.position,o.moveCenter);o.direction=Math.atan2(-h,-l),o.velocity.angle=o.direction;break}default:{if($(o.position,a.canvas.size,O.origin,o.getRadius(),i))return;switch(o.outType){case C.outside:{o.position.x=Math.floor(V({min:-o.moveCenter.radius,max:o.moveCenter.radius}))+o.moveCenter.x,o.position.y=Math.floor(V({min:-o.moveCenter.radius,max:o.moveCenter.radius}))+o.moveCenter.y;const{dx:r,dy:t}=S(o.position,o.moveCenter);o.moveCenter.radius&&(o.direction=Math.atan2(t,r),o.velocity.angle=o.direction);break}case C.normal:{const r=o.options.move.warp,t=a.canvas.size,u={bottom:t.height+o.getRadius()+o.offset.y,left:-o.getRadius()-o.offset.x,right:t.width+o.getRadius()+o.offset.x,top:-o.getRadius()-o.offset.y},f=o.getRadius(),d=K(o.position,f);i===c.right&&d.left>t.width+o.offset.x?(o.position.x=u.left,o.initialPosition.x=o.position.x,r||(o.position.y=x()*t.height,o.initialPosition.y=o.position.y)):i===c.left&&d.right<-o.offset.x&&(o.position.x=u.right,o.initialPosition.x=o.position.x,r||(o.position.y=x()*t.height,o.initialPosition.y=o.position.y)),i===c.bottom&&d.top>t.height+o.offset.y?(r||(o.position.x=x()*t.width,o.initialPosition.x=o.position.x),o.position.y=u.top,o.initialPosition.y=o.position.y):i===c.top&&d.bottom<-o.offset.y&&(r||(o.position.x=x()*t.width,o.initialPosition.x=o.position.x),o.position.y=u.bottom,o.initialPosition.y=o.position.y);break}}break}}}}const Go=(n,o)=>n.default===o||n.bottom===o||n.left===o||n.right===o||n.top===o;class qo{constructor(o){this._addUpdaterIfMissing=(i,s,e)=>{const a=i.options.move.outModes;!this.updaters.has(s)&&Go(a,s)&&this.updaters.set(s,e(this.container))},this._updateOutMode=(i,s,e,a)=>{for(const r of this.updaters.values())r.update(i,a,s,e)},this.container=o,this.updaters=new Map}init(o){this._addUpdaterIfMissing(o,y.bounce,i=>new Ho(i)),this._addUpdaterIfMissing(o,y.out,i=>new jo(i)),this._addUpdaterIfMissing(o,y.destroy,i=>new No(i)),this._addUpdaterIfMissing(o,y.none,i=>new Wo(i))}isEnabled(o){return!o.destroyed&&!o.spawning}update(o,i){const s=o.options.move.outModes;this._updateOutMode(o,i,s.bottom??s.default,c.bottom),this._updateOutMode(o,i,s.left??s.default,c.left),this._updateOutMode(o,i,s.right??s.default,c.right),this._updateOutMode(o,i,s.top??s.default,c.top)}}async function Jo(n,o=!0){n.checkVersion("3.9.1"),await n.addParticleUpdater("outModes",i=>Promise.resolve(new qo(i)),o)}var M;(function(n){n[n.r=1]="r",n[n.g=2]="g",n[n.b=3]="b",n[n.a=5]="a"})(M||(M={}));class Ko{constructor(){this.key="rgb",this.stringPrefix="rgb"}handleColor(o){const i=o.value,s=i.rgb??o.value;if(s.r!==void 0)return s}handleRangeColor(o){const i=o.value,s=i.rgb??o.value;if(s.r!==void 0)return{r:v(s.r),g:v(s.g),b:v(s.b)}}parseString(o){if(!o.startsWith(this.stringPrefix))return;const i=/rgba?\(\s*(\d{1,3})\s*[\s,]\s*(\d{1,3})\s*[\s,]\s*(\d{1,3})\s*([\s,]\s*(0|1|0?\.\d+|(\d{1,3})%)\s*)?\)/i,s=i.exec(o),e=10;return s?{a:s.length>4?G(s[M.a]):1,b:parseInt(s[M.b],e),g:parseInt(s[M.g],e),r:parseInt(s[M.r],e)}:void 0}}async function Qo(n,o=!0){n.checkVersion("3.9.1"),await n.addColorManager(new Ko,o)}const b=0;class Xo{init(o){const i=o.container,s=o.options.size,e=s.animation;e.enable&&(o.size.velocity=(o.retina.sizeAnimationSpeed??i.retina.sizeAnimationSpeed)/q*i.retina.reduceFactor,e.sync||(o.size.velocity*=x()))}isEnabled(o){return!o.destroyed&&!o.spawning&&o.size.enable&&((o.size.maxLoops??b)<=b||(o.size.maxLoops??b)>b&&(o.size.loops??b)<(o.size.maxLoops??b))}reset(o){o.size.loops=b}update(o,i){this.isEnabled(o)&&J(o,o.size,!0,o.options.size.animation.destroy,i)}}async function Yo(n,o=!0){n.checkVersion("3.9.1"),await n.addParticleUpdater("size",()=>Promise.resolve(new Xo),o)}async function an(n,o=!0){n.checkVersion("3.9.1"),await To(n,!1),await Lo(n,!1),await Qo(n,!1),await po(n,!1),await Oo(n,!1),await Ro(n,!1),await Eo(n,!1),await Jo(n,!1),await Yo(n,!1),await n.refresh(o)}export{an as loadBasic};
